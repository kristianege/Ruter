# --- 1. Setup: Load necessary packages ---
library(shiny)
library(sf)
library(giscoR)
library(dplyr)
library(readr)
library(osrm)
library(TSP)
library(xml2)
library(purrr)
library(lubridate)
library(tidyr)
library(RColorBrewer)
library(leaflet)
library(DT) # For pæne tabeller
library(htmlwidgets) # Til at gemme kort som HTML
library(openxlsx) # Til at gemme Excel filer

# Øg max upload størrelse hvis nødvendigt (her sat til 50MB)
options(shiny.maxRequestSize = 50*1024^2)

# --- HJÆLPEFUNKTIONER ---

# Opdateret funktion til at udtrække data fra uploadede XML filer
extract_data_uploaded <- function(file_path, file_name) {
  # Vi bruger tryCatch for at undgå at én dårlig fil stopper hele processen
  tryCatch({
    xml <- read_xml(file_path)
    tibble(
      FileName = file_name,
      StartDate = xml_find_first(xml, "//SFMeasurement") %>% xml_attr("StartDate") %>% ymd_hms(),
      EndDate = xml_find_first(xml, "//SFMeasurement") %>% xml_attr("EndDate") %>% ymd_hms(),
      Key = xml_find_first(xml, "//HymerLocation") %>% xml_attr("Key"),
      Name = xml_find_first(xml, "//HymerLocation") %>% xml_attr("Name"),
      Location = xml_find_first(xml, "//HymerLocation") %>% xml_attr("Location"),
      InstrId = xml_find_first(xml, "//CurMeter") %>% xml_attr("InstrId"),
      Value = as.numeric(xml_find_first(xml, "//WLStart") %>% xml_attr("Value")),
      FieldStaffId = xml_find_first(xml, "//FieldStaff") %>% xml_attr("FieldStaffId")
    )
  }, error = function(e) {
    warning(paste("Fejl i fil:", file_name, "-", e$message))
    return(tibble()) # Returner tom tibble ved fejl
  })
}

# Beregn rutetid
calculate_route_time <- function(route, time_matrix, all_locations) {
  full_path <- c(1, route, 1)
  travel_time <- sum(sapply(1:(length(full_path) - 1), function(k) {
    time_matrix[full_path[k], full_path[k + 1]]
  }))
  service_time <- sum(all_locations$SampleDuration_min[route])
  return(travel_time + service_time)
}

# Tjek konflikter
check_conflicts <- function(proposed_route_indices, all_locs, conflict_list) {
  if (length(conflict_list) == 0) return(FALSE)
  route_station_ids <- all_locs$StationNumber[proposed_route_indices]
  for (conflict_group in conflict_list) {
    matches <- sum(route_station_ids %in% conflict_group)
    if (matches > 1) return(TRUE) 
  }
  return(FALSE)
}

# Hjælpefunktion til at optimere rækkefølge af en liste indeks
optimize_sequence <- function(indices, time_mat) {
  if(length(indices) < 2) return(indices)
  
  stops <- c(1, indices) # 1 er Origin
  
  if(max(stops) > nrow(time_mat)) return(indices)
  
  sub_mat <- time_mat[stops, stops]
  
  tryCatch({
    set.seed(42) 
    tsp <- ATSP(sub_mat)
    tour <- solve_TSP(tsp, method = "arbitrary_insertion", control = list(start = 1))
    ord <- as.integer(tour)
    new_stops <- stops[ord]
    return(new_stops[new_stops != 1])
  }, error = function(e) {
    return(indices) 
  })
}

# --- UI DEFINITION ---

ui <- fluidPage(
  titlePanel("Ruteplanlægning - Hydrometri"),
  
  sidebarLayout(
    sidebarPanel(
      h4("1. Opsætning"),
      selectInput("season", "Vælg Sæson:", choices = c("Vinter", "Sommer"), selected = "Vinter"),
      numericInput("tour_capacity", "Max tid pr. dag (min):", value = 354, min = 100, max = 600),
      numericInput("min_stops", "Min. stationer pr. dag:", value = 1, min = 1, max = 20),
      checkboxInput("force_osrm", "Tving ny OSRM-beregning (nulstil matrix-rettelser)", value = FALSE),
      
      hr(),
      h4("Tidsindstillinger (Generelt)"),
      numericInput("time_chem", "Kemi tid (min):", value = 10, min = 0),
      numericInput("time_data", "Data tid (min):", value = 10, min = 0),
      numericInput("time_base_extra", "Generel ekstra tid (min):", value = 5, min = 0),
      helpText("Disse lægges til 'Upper Quantile' (75% fraktil) for alle stationer."),
      
      hr(),
      h4("2. Datafiler"),
      helpText("Upload alle filer herunder. XML-filer skal vælges samlet."),
      
      fileInput("file_blg", "1. Upload BLG_togter.csv", accept = ".csv"),
      fileInput("file_wms", "2. Upload HydrometristationerWMS.csv", accept = ".csv"),
      fileInput("xml_files", "3. Upload XML Filer (Vælg alle)", multiple = TRUE, accept = ".xml"),
      
      hr(),
      actionButton("load_data", "Indlæs og Behandl Data", class = "btn-primary", width = "100%"),
      br(), br(),
      
      uiOutput("run_button_ui")
    ),
    
    mainPanel(
      tabsetPanel(
        tabPanel("Begrænsninger & Regler", 
                 h3("Konfigurer Ruter"),
                 p("Her opsætter du reglerne for ruterne. Data skal være indlæst først."),
                 
                 fluidRow(
                   column(4,
                          wellPanel(
                            h4("1. Fravælg Stationer"),
                            helpText("Vælg stationer der IKKE skal besøges."),
                            uiOutput("exclude_ui"),
                            actionButton("reset_exclude", "Nulstil fravalg", class = "btn-xs")
                          )
                   ),
                   column(4,
                          wellPanel(
                            h4("2. Tving Sammen"),
                            helpText("Vælg stationer der SKAL køres på samme dag."),
                            uiOutput("together_ui"), 
                            actionButton("add_together", "Tilføj Gruppe", icon = icon("plus")),
                            hr(),
                            h5("Aktive Grupper:"),
                            DTOutput("table_together"), 
                            br(),
                            actionButton("delete_together", "Slet Valgte", class = "btn-warning btn-xs"),
                            actionButton("clear_together", "Slet Alle", icon = icon("trash"), class = "btn-danger btn-xs")
                          )
                   ),
                   column(4,
                          wellPanel(
                            h4("3. Tving Adskilt"),
                            helpText("Vælg stationer der IKKE må være på samme tur."),
                            uiOutput("apart_ui"), 
                            actionButton("add_apart", "Tilføj Konflikt", icon = icon("plus")),
                            hr(),
                            h5("Aktive Konflikter:"),
                            DTOutput("table_apart"), 
                            br(),
                            actionButton("delete_apart", "Slet Valgte", class = "btn-warning btn-xs"),
                            actionButton("clear_apart", "Slet Alle", icon = icon("trash"), class = "btn-danger btn-xs")
                          )
                   )
                 ),
                 hr(),
                 fluidRow(
                   column(12,
                          wellPanel(
                            h4("4. Specifikke Tidsjusteringer"),
                            p("Her kan du give enkelte stationer mere/mindre ekstra tid end den generelle sats."),
                            fluidRow(
                              column(4, uiOutput("time_override_ui")),
                              column(3, numericInput("override_val", "Ekstra tid (min):", value = 15, min = 0)),
                              column(2, br(), actionButton("add_override", "Tilføj", icon = icon("plus")))
                            ),
                            h5("Aktive Justeringer (Overskriver 'Generel ekstra tid'):"),
                            DTOutput("table_overrides"),
                            br(),
                            actionButton("delete_override", "Slet Valgte", class = "btn-warning btn-xs"),
                            actionButton("clear_override", "Ryd Alle", class = "btn-danger btn-xs")
                          )
                   )
                 )
        ),
        
        tabPanel("Resultat (Kort)", 
                 h3("Optimeret Ruteplan"),
                 leafletOutput("map_optimized", height = "600px"),
                 verbatimTextOutput("summary_text"),
                 br(),
                 downloadButton("download_map_html", "Download Kort (HTML)", class = "btn-info")
        ),
        
        tabPanel("Resultat (Tabel)", 
                 h3("Køreplan Detaljer (Ny Plan)"),
                 DTOutput("schedule_table"),
                 br(),
                 downloadButton("download_plan", "Download CSV"),
                 downloadButton("download_plan_xlsx", "Download Excel", class = "btn-success"),
                 downloadButton("download_plan_html", "Download HTML", class = "btn-info"),
                 downloadButton("download_blg_format", "Download som BLG-fil (CSV)", class = "btn-primary")
        ),
        
        tabPanel("Nuværende Plan (Kort)",
                 h3("Nuværende Plan (Manuelt/Optimeret Rækkefølge)"),
                 p("Viser den nuværende plan (baseret på BLG-filen, inkl. dine manuelle ændringer)."),
                 leafletOutput("map_current", height = "600px"),
                 br(),
                 downloadButton("download_map_current_html", "Download Kort (HTML)", class = "btn-info")
        ),
        
        tabPanel("Nuværende Plan (Tabel)",
                 h3("Køreplan Detaljer (Nuværende Plan)"),
                 p("Viser den nuværende plan med beregnede køretider (optimeret rækkefølge) og prøvetagningstider."),
                 DTOutput("current_schedule_table"),
                 br(),
                 downloadButton("download_current_plan", "Download CSV"),
                 downloadButton("download_current_plan_xlsx", "Download Excel", class = "btn-success"),
                 downloadButton("download_current_plan_html", "Download HTML", class = "btn-info")
        ),
        
        tabPanel("Sammenligning",
                 h3("Nuværende vs. Ny"),
                 p("Bemærk: Statistikken dækker kun stationer, der er inkluderet i beregningen (dvs. fraregnet dine manuelle fravalg)."),
                 fluidRow(
                   column(12, h4("Statistik"), tableOutput("comparison_table"))
                 )
        ),
        
        tabPanel("Rådata & Manuel Planlægning",
                 h3("Indlæste Data (Editerbare)"),
                 p("Her kan du se og rette i den indlæste plan (BLG Togter). Ændringer her bruges som 'Nuværende Plan' når du trykker 'Kør Ruteberegning'."),
                 tabsetPanel(
                   tabPanel("BLG Togter (Editerbar)", 
                            DTOutput("table_blg"),
                            helpText("Dobbeltklik i en celle for at redigere (f.eks. skift togt nummer). Header og ID er låst.")
                   ),
                   tabPanel("WMS Stationer", DTOutput("table_wms"))
                 )
        ),
        
        tabPanel("Rejsetidsmatrix",
                 h3("Beregnet Rejsetidsmatrix (Editerbar)"),
                 p("Viser rejsetid i minutter. Dobbeltklik på en celle for at ændre tiden manuelt. Ændringen træder i kraft ved næste beregning (hvis 'Tving ny beregning' er slået fra)."),
                 DTOutput("table_matrix")
        )
      )
    )
  )
)

# --- SERVER DEFINITION ---

server <- function(input, output, session) {
  
  # Reaktive værdier
  vals <- reactiveValues(
    base_data = NULL,
    measure_summary = NULL, 
    measure_summary_max = NULL, 
    all_locations = NULL,
    routing_plan = NULL,
    current_plan_detailed = NULL, 
    time_matrix = NULL,
    all_locations_final = NULL,
    data_loaded = FALSE,
    # CSV data storage
    BLG_togter = NULL,
    st = NULL, 
    HydrometristationerWMS = NULL,
    # Regler som DataFrames for nemmere visning i DT
    force_together_df = data.frame(ID = integer(), Stationer = character(), stringsAsFactors = FALSE),
    force_apart_df = data.frame(ID = integer(), Stationer = character(), stringsAsFactors = FALSE),
    time_overrides = data.frame(StationNumber = character(), Time = numeric(), stringsAsFactors = FALSE)
  )
  
  # --- TRIN 1: INDLÆS DATA ---
  observeEvent(input$load_data, {
    if (is.null(input$file_blg) || is.null(input$file_wms) || is.null(input$xml_files)) {
      showNotification("Du skal uploade både CSV filer og XML filer først!", type = "warning")
      return()
    }

    withProgress(message = 'Indlæser data...', value = 0, {
      
      path_blg <- input$file_blg$datapath
      path_wms <- input$file_wms$datapath
      
      origin_df <- data.frame(StationNumber = "Origin", StationName = "Svendborg Lab", Label = "Origin - Svendborg Lab", Longitude = 10.2864, Latitude = 55.14703, SampleDuration_min = 0)
      Ejby_sluse <- data.frame(StationNumber = "45001606", StationName = "Ejby Sluse", Label = "45001606 - Ejby Sluse", Longitude = 10.41987, Latitude = 55.39948, SampleDuration_min = 10)
      
      incProgress(0.2, detail = "Læser CSV filer")
      tryCatch({
        BLG_togter <- read_delim(path_blg, delim = ";", escape_double = FALSE, trim_ws = TRUE, show_col_types = FALSE) %>%
          mutate(gammel = as.character(gammel), ny = as.character(ny))
        
        HydrometristationerWMS <- read_delim(path_wms, delim = ";", escape_double = FALSE, trim_ws = TRUE, show_col_types = FALSE)
      }, error = function(e) {
        showNotification("Fejl ved indlæsning af CSV filer.", type = "error")
        return(NULL)
      })
      
      incProgress(0.4, detail = "Behandler XML filer")
      measure_data_df <- map2_df(input$xml_files$datapath, input$xml_files$name, extract_data_uploaded)
      
      if(nrow(measure_data_df) == 0) {
        showNotification("Ingen data fundet i XML filerne.", type = "error")
        return(NULL)
      }
      
      incProgress(0.7, detail = "Renser data")
      
      measure_data_df <- measure_data_df %>%
        left_join(select(BLG_togter, gammel, ny), by = c("Key" = "gammel")) %>%
        mutate(StationNumber = ifelse(is.na(ny), Key, ny)) %>%
        select(-ny, -Key) %>%
        inner_join(BLG_togter, by = c("StationNumber" = "ny")) %>%
        select(-gammel, -navn, -togt) %>%
        mutate(InstrId = ifelse(StationNumber == 45001618, "spand_ur", InstrId)) %>%
        drop_na() %>%
        mutate(
          duration_minutes = as.numeric(difftime(EndDate, StartDate, units = "mins")),
          Location = gsub(",| ", "_", Location),
          Name = gsub(" ", "_", Name),
          st_name = paste(Name, Location, sep = "_"),
          dayofyear = yday(StartDate),
          Season = ifelse(month(StartDate) %in% c(12, 1, 2, 3, 4, 5), "Vinter", "Sommer")
        ) %>%
        filter(duration_minutes >= 0, duration_minutes < 100) %>%
        select(-Location)
      
      # Beregn basis statistik (Quantiles) - UDEN at lægge fast tid til endnu
      measure_summary <- measure_data_df %>%
        group_by(StationNumber, st_name, Season, InstrId) %>%
        summarise(
          median_duration = median(duration_minutes),
          upperquantile = quantile(duration_minutes, 0.75),
          .groups = 'drop'
        )
      
      measure_summary_temp <- measure_summary %>%
        mutate(samlet_tid = upperquantile + 10 + 10 + 5) %>%
        group_by(st_name, StationNumber, Season) %>%
        summarise(joint_sample_duration = max(samlet_tid), .groups = 'drop')
        
      # === NY LOGIK: UDTRÆK NAVN FRA WMS FIL ===
      # WMS format: "45001919 Lundby Å, 2.01"
      # Vi splitter Id ved første mellemrum
      st <- HydrometristationerWMS %>%
        mutate(
          st = substr(Id, start = 1, stop = 8),
          StationName = substring(Id, 10), # Alt efter de første 9 tegn (8 tal + 1 mellemrum)
          Label = paste(st, "-", StationName)
        ) %>%
        select(-Id, StationNumber = st, StationName, Label, Latitude = lat, Longitude = lon)
      
      measure_summary_temp <- measure_summary_temp %>%
        left_join(st, by = "StationNumber") %>%
        drop_na() %>%
        rename(SampleDuration_min = joint_sample_duration)
        
      # --- FIX: TILFØJ EJBY SLUSE TIL UI LISTEN HER ---
      Ejby_UI <- Ejby_sluse %>%
        mutate(st_name = "Ejby Sluse", Season = "Begge") 
      
      measure_summary_temp <- bind_rows(measure_summary_temp, Ejby_UI)
      # ------------------------------------------------
      
      # Gem til reactive values
      vals$measure_summary <- measure_summary # Gemmer basis
      vals$measure_summary_max <- measure_summary_temp # Gemmer temp for UI lister
      vals$origin_df <- origin_df
      vals$Ejby_sluse <- Ejby_sluse
      vals$BLG_togter <- BLG_togter
      vals$st <- st
      vals$HydrometristationerWMS <- HydrometristationerWMS
      vals$data_loaded <- TRUE
      
      incProgress(1, detail = "Færdig!")
    })
  })
  
  # --- TRIN 2: UI GENERERING & REGLER ---
  
  output$run_button_ui <- renderUI({
    req(vals$data_loaded)
    actionButton("run_calc", "Kør Ruteberegning", class = "btn-success", width = "100%", icon = icon("play"), style="font-size: 1.2em;")
  })
  
  # Hent stationsliste som Named List (Navn = ID) for Selectize
  stations_list_named <- reactive({
    req(vals$measure_summary_max)
    # Lav en navngivet vektor: c("45001919 - Lundby Å" = "45001919", ...)
    choices <- setNames(vals$measure_summary_max$StationNumber, vals$measure_summary_max$Label)
    # Sorter efter label (navn)
    choices[order(names(choices))]
  })
  
  # A. EXCLUDE UI
  output$exclude_ui <- renderUI({
    if(!vals$data_loaded) return(selectInput("dummy", NULL, choices = "Indlæs data først..."))
    selectizeInput("exclude_stations", NULL, choices = stations_list_named(), multiple = TRUE, options = list(placeholder = 'Søg efter navn eller nummer...'))
  })
  observeEvent(input$reset_exclude, { updateSelectizeInput(session, "exclude_stations", selected = character(0)) })
  
  # B. TOGETHER (Tabel baseret)
  output$together_ui <- renderUI({
    if(!vals$data_loaded) return(selectInput("dummy", NULL, choices = "Indlæs data først..."))
    selectizeInput("sel_together", NULL, choices = stations_list_named(), multiple = TRUE, options = list(placeholder = 'Søg efter navn eller nummer...'))
  })
  
  observeEvent(input$add_together, {
    req(input$sel_together)
    if(length(input$sel_together) < 2) {
      showNotification("Vælg mindst 2 stationer.", type = "warning")
      return()
    }
    
    # Hent labels for display i tabel
    labels <- names(stations_list_named())[match(input$sel_together, stations_list_named())]
    display_str <- paste(labels, collapse = "; ")
    
    # Tilføj til DF (Gem ID'er internt, vis Navne eksternt)
    new_id <- if(nrow(vals$force_together_df) == 0) 1 else max(vals$force_together_df$ID) + 1
    
    # Vi gemmer ID'erne som en streng "ID1, ID2" til logikken
    ids_str <- paste(input$sel_together, collapse = ", ")
    
    new_row <- data.frame(ID = new_id, Stationer = display_str, IDs_Hidden = ids_str, stringsAsFactors = FALSE)
    vals$force_together_df <- rbind(vals$force_together_df, new_row)
    updateSelectizeInput(session, "sel_together", selected = character(0))
  })
  
  observeEvent(input$delete_together, {
    req(input$table_together_rows_selected)
    vals$force_together_df <- vals$force_together_df[-input$table_together_rows_selected, ]
  })
  observeEvent(input$clear_together, { vals$force_together_df <- vals$force_together_df[0,] })
  
  output$table_together <- renderDT({
    # Vis kun "Stationer" kolonnen (med navne), skjul ID og IDs_Hidden
    df_show <- vals$force_together_df %>% select(Stationer)
    datatable(df_show, selection = 'multiple', options = list(dom = 't', paging = FALSE), rownames = FALSE)
  })
  
  # C. APART (Tabel baseret)
  output$apart_ui <- renderUI({
    if(!vals$data_loaded) return(selectInput("dummy", NULL, choices = "Indlæs data først..."))
    selectizeInput("sel_apart", NULL, choices = stations_list_named(), multiple = TRUE, options = list(placeholder = 'Søg efter navn eller nummer...'))
  })
  
  observeEvent(input$add_apart, {
    req(input$sel_apart)
    if(length(input$sel_apart) < 2) {
      showNotification("Vælg mindst 2 stationer.", type = "warning")
      return()
    }
    
    labels <- names(stations_list_named())[match(input$sel_apart, stations_list_named())]
    display_str <- paste(labels, collapse = "; ")
    ids_str <- paste(input$sel_apart, collapse = ", ")
    
    new_id <- if(nrow(vals$force_apart_df) == 0) 1 else max(vals$force_apart_df$ID) + 1
    new_row <- data.frame(ID = new_id, Stationer = display_str, IDs_Hidden = ids_str, stringsAsFactors = FALSE)
    vals$force_apart_df <- rbind(vals$force_apart_df, new_row)
    updateSelectizeInput(session, "sel_apart", selected = character(0))
  })
  
  observeEvent(input$delete_apart, {
    req(input$table_apart_rows_selected)
    vals$force_apart_df <- vals$force_apart_df[-input$table_apart_rows_selected, ]
  })
  observeEvent(input$clear_apart, { vals$force_apart_df <- vals$force_apart_df[0,] })
  
  output$table_apart <- renderDT({
    df_show <- vals$force_apart_df %>% select(Stationer)
    datatable(df_show, selection = 'multiple', options = list(dom = 't', paging = FALSE), rownames = FALSE)
  })
  
  # D. TIME OVERRIDE (NU OGSÅ SOM TABEL MED SLET MULIGHED)
  output$time_override_ui <- renderUI({
    if(!vals$data_loaded) return(selectInput("dummy", NULL, choices = "Indlæs data først..."))
    selectizeInput("sel_override_st", NULL, choices = stations_list_named(), multiple = FALSE, options = list(placeholder = 'Vælg station...'))
  })
  
  observeEvent(input$add_override, {
    req(input$sel_override_st, input$override_val)
    # Fjern eksisterende hvis findes
    current <- vals$time_overrides %>% filter(StationNumber != input$sel_override_st)
    new_entry <- data.frame(StationNumber = input$sel_override_st, Time = input$override_val, stringsAsFactors = FALSE)
    vals$time_overrides <- rbind(current, new_entry)
    updateSelectizeInput(session, "sel_override_st", selected = character(0))
  })
  
  observeEvent(input$delete_override, {
    req(input$table_overrides_rows_selected)
    vals$time_overrides <- vals$time_overrides[-input$table_overrides_rows_selected, ]
  })
  
  observeEvent(input$clear_override, { vals$time_overrides <- data.frame(StationNumber = character(), Time = numeric(), stringsAsFactors = FALSE) })
  
  output$table_overrides <- renderDT({
    # Flet med navne for visning
    if(nrow(vals$time_overrides) > 0) {
      df_show <- vals$time_overrides %>%
        left_join(vals$st, by = "StationNumber") %>%
        select(Label, Time) %>%
        rename(Station = Label, "Ekstra Tid (min)" = Time)
    } else {
      df_show <- data.frame(Station = character(), "Ekstra Tid (min)" = numeric(), check.names=FALSE)
    }
    
    datatable(df_show, selection = 'multiple', options = list(dom = 't', paging = FALSE), rownames = FALSE)
  })
  
  # --- EDITERBAR BLG TABEL ---
  observeEvent(input$table_blg_cell_edit, {
    info <- input$table_blg_cell_edit
    # Opdater data i hukommelsen
    vals$BLG_togter[info$row, info$col] <- info$value
  })
  
  # --- TRIN 3: BEREGNING ---
  
  observeEvent(input$run_calc, {
    req(vals$data_loaded)
    
    withProgress(message = 'Beregner Ruter...', value = 0, {
      
      incProgress(0.1, detail = "Beregner tidsforbrug pr. station")
      
      # 1. BEREGN TIDER
      df_calc <- vals$measure_summary
      overrides <- vals$time_overrides
      df_calc <- df_calc %>%
        left_join(overrides, by = "StationNumber") %>%
        rename(Manual_Extra = Time)
      
      df_calc <- df_calc %>%
        mutate(
          Kemi_tid = input$time_chem,
          data_tid = input$time_data,
          ekstra_tid = ifelse(!is.na(Manual_Extra), Manual_Extra, input$time_base_extra),
          samlet_tid = upperquantile + Kemi_tid + data_tid + ekstra_tid
        )
      
      measure_summary_max <- df_calc %>%
        group_by(st_name, StationNumber, Season) %>%
        summarise(joint_sample_duration = max(samlet_tid), .groups = 'drop') %>%
        left_join(vals$st, by = "StationNumber") %>%
        drop_na() %>%
        rename(SampleDuration_min = joint_sample_duration)
      
      exclude_list <- input$exclude_stations
      
      # Konverter DF regler tilbage til lister for algoritmen (Brug IDs_Hidden kolonnen)
      force_together <- if(nrow(vals$force_together_df) > 0) {
        lapply(strsplit(vals$force_together_df$IDs_Hidden, ", "), function(x) trimws(x))
      } else { list() }
      
      force_apart <- if(nrow(vals$force_apart_df) > 0) {
        lapply(strsplit(vals$force_apart_df$IDs_Hidden, ", "), function(x) trimws(x))
      } else { list() }
      
      tour_capacity <- input$tour_capacity
      season_sel <- input$season
      
      # Filtrering
      stations_df <- measure_summary_max %>%
        filter(Season == season_sel) %>%
        filter(!StationNumber %in% exclude_list) %>%
        select(-Season, -st_name) %>%
        bind_rows(vals$Ejby_sluse)
      
      if(vals$Ejby_sluse$StationNumber %in% exclude_list) {
        stations_df <- stations_df %>% filter(StationNumber != vals$Ejby_sluse$StationNumber)
      }
      stations_df <- distinct(stations_df, StationNumber, .keep_all = TRUE)
      
      all_locations <- bind_rows(vals$origin_df, stations_df)
      rownames(all_locations) <- NULL 
      
      incProgress(0.3, detail = "Henter/tjekker afstande (OSRM)")
      
      # MATRIX REUSE LOGIC
      current_ids <- all_locations$StationNumber
      matrix_exists <- !is.null(vals$time_matrix)
      
      reuse_matrix <- FALSE
      if(matrix_exists) {
        if(nrow(vals$time_matrix) == length(current_ids) && 
           all(rownames(vals$time_matrix) == current_ids)) {
           reuse_matrix <- TRUE
        }
      }
      
      if(reuse_matrix && !input$force_osrm) {
         time_matrix <- vals$time_matrix
         showNotification("Genbruger eksisterende rejsetidsmatrix (inkl. evt. rettelser).", type = "message")
      } else {
         # Hent ny matrix
         tryCatch({
            travel_times <- osrmTable(loc = all_locations[, c("Longitude", "Latitude")])
            time_matrix <- travel_times$durations
            rownames(time_matrix) <- current_ids
            colnames(time_matrix) <- current_ids
            vals$time_matrix <- time_matrix # Gem matrix med ID'er
         }, error = function(e) {
            showNotification("Fejl ved OSRM kald. Tjek internetforbindelse.", type = "error")
            return(NULL)
         })
      }
      
      vals$all_locations_final <- all_locations
      
      incProgress(0.5, detail = "Optimerer ruter (Clarke-Wright)")
      
      # VRP Analysis
      station_indices <- 2:nrow(all_locations)
      savings <- data.frame(i = integer(), j = integer(), saving = double())
      
      for (i in station_indices) {
        for (j in station_indices) {
          if (i < j) {
            saving_val <- time_matrix[1, i] + time_matrix[1, j] - time_matrix[i, j]
            savings <- rbind(savings, data.frame(i = i, j = j, saving = saving_val))
          }
        }
      }
      
      # Force Together (Boost savings)
      for (group in force_together) {
        group_indices <- match(group, all_locations$StationNumber)
        group_indices <- group_indices[!is.na(group_indices)]
        
        if (length(group_indices) > 1) {
          pairs <- combn(group_indices, 2)
          for (k in 1:ncol(pairs)) {
            idx_i <- min(pairs[, k])
            idx_j <- max(pairs[, k])
            row_id <- which(savings$i == idx_i & savings$j == idx_j)
            if (length(row_id) > 0) {
              savings$saving[row_id] <- 10000000 + savings$saving[row_id]
            }
          }
        }
      }
      
      savings <- savings %>% arrange(desc(saving))
      routes <- as.list(station_indices)
      
      # Merge Loop
      for (k in 1:nrow(savings)) {
        i <- savings$i[k]
        j <- savings$j[k]
        
        route_i_idx <- which(sapply(routes, function(r) i %in% r))
        route_j_idx <- which(sapply(routes, function(r) j %in% r))
        
        if (length(route_i_idx) == 0 || length(route_j_idx) == 0) next 
        
        if (route_i_idx != route_j_idx) {
          route_i <- routes[[route_i_idx]]
          route_j <- routes[[route_j_idx]]
          
          if ((i == route_i[1] || i == route_i[length(route_i)]) &&
              (j == route_j[1] || j == route_j[length(route_j)])) {
            
            if (i == route_i[1]) route_i <- rev(route_i)
            if (j == route_j[length(route_j)]) route_j <- rev(route_j)
            
            new_route <- c(route_i, route_j)
            
            # Intelligent Merge Logic
            current_time <- calculate_route_time(new_route, time_matrix, all_locations)
            time_ok <- current_time <= tour_capacity
            
            if (!time_ok) {
               opt_route <- optimize_sequence(new_route, time_matrix)
               opt_time <- calculate_route_time(opt_route, time_matrix, all_locations)
               if (opt_time <= tour_capacity) {
                 time_ok <- TRUE
                 new_route <- opt_route 
               }
            }
            
            conflict_found <- check_conflicts(new_route, all_locations, force_apart)
            
            if (time_ok && !conflict_found) {
              routes[[route_i_idx]] <- new_route
              routes[[route_j_idx]] <- NULL
            }
          }
        }
      }
      
      incProgress(0.8, detail = "Finjusterer rækkefølge (TSP)")
      set.seed(42)

      daily_plans <- lapply(1:length(routes), function(day) {
        route_indices <- routes[[day]]
        original_time <- calculate_route_time(route_indices, time_matrix, all_locations)
        route_time <- original_time 
        
        if(length(route_indices) > 2) {
          stops_for_day <- c(1, route_indices) 
          sub_matrix <- time_matrix[stops_for_day, stops_for_day]
          tsp_prob <- ATSP(sub_matrix)
          
          best_tour <- NULL
          best_len <- Inf
          
          for(run in 1:10) {
            tour <- solve_TSP(tsp_prob, method = "arbitrary_insertion", control = list(start = 1))
            len <- tour_length(tour)
            if(len < best_len) {
              best_len <- len
              best_tour <- tour
            }
          }
          
          ordered_indices_local <- as.integer(best_tour)
          actual_route_order <- stops_for_day[ordered_indices_local]
          actual_route_order <- actual_route_order[actual_route_order != 1]
          
          optimized_time <- calculate_route_time(actual_route_order, time_matrix, all_locations)
          
          if(optimized_time <= original_time) {
            route_indices <- actual_route_order
            route_time <- optimized_time
          }
        }
        
        data.frame(
          Day = day,
          StopOrder = 1:length(route_indices),
          StationNumber = all_locations$StationNumber[route_indices],
          StationName = all_locations$StationName[route_indices],
          DailyRouteTime_min = round(route_time, 1)
        )
      })
      
      routing_plan_df <- bind_rows(daily_plans) %>%
        left_join(select(stations_df, -any_of("StationName")), by = "StationNumber") %>% # FIX DUPLICATE COLUMNS
        arrange(Day, StopOrder)
      
      vals$routing_plan <- routing_plan_df
      
      # --- BEREGN DETALJERET TABEL FOR NUVÆRENDE PLAN (MED ÆNDRINGER) ---
      # Brug den redigerede version (vals$BLG_togter)
      nuv_data <- vals$BLG_togter %>%
        mutate(StationNumber = ny) %>%
        filter(StationNumber %in% all_locations$StationNumber)
      
      if(nrow(nuv_data) > 0) {
        current_plans_list <- lapply(unique(nuv_data$togt), function(d) {
          day_stations <- nuv_data %>% filter(togt == d) %>% pull(StationNumber)
          indices <- match(day_stations, all_locations$StationNumber)
          indices <- indices[!is.na(indices)]
          
          if(length(indices) == 0) return(NULL)
          
          optimized_idx <- optimize_sequence(indices, time_matrix)
          route_time <- calculate_route_time(optimized_idx, time_matrix, all_locations)
          
          data.frame(
            Day = d,
            StopOrder = 1:length(optimized_idx),
            StationNumber = all_locations$StationNumber[optimized_idx],
            StationName = all_locations$StationName[optimized_idx],
            DailyRouteTime_min = round(route_time, 1)
          )
        })
        
        current_plan_df <- bind_rows(current_plans_list) %>%
          left_join(select(stations_df, -any_of("StationName")), by = "StationNumber") %>% # FIX DUPLICATE COLUMNS
          arrange(Day, StopOrder)
        
        vals$current_plan_detailed <- current_plan_df
      } else {
        vals$current_plan_detailed <- NULL
      }
      
      # --- TJEK OM REGLER OVERHOLDES (ADVARSLER) ---
      warnings_list <- c()
      
      # Tjek: Tvungne grupper splittet?
      for (i in seq_along(force_together)) {
        group <- as.character(force_together[[i]])
        group_in_plan <- routing_plan_df %>% filter(as.character(StationNumber) %in% group)
        station_days <- unique(group_in_plan$Day)
        if (length(station_days) > 1) {
          stations_split <- paste(unique(group_in_plan$StationName), collapse=", ") # Brug Navn nu!
          warnings_list <- c(warnings_list, paste0("Tvunget gruppe ", i, " (", stations_split, ") splittet over ", length(station_days), " dage."))
        }
      }
      
      # Tjek: Minimum stationer pr dag?
      stops_per_day <- table(routing_plan_df$Day)
      bad_days <- names(stops_per_day)[stops_per_day < input$min_stops]
      if(length(bad_days) > 0) {
        warnings_list <- c(warnings_list, paste0("Minimumsgrænse underskredet på dag: ", paste(bad_days, collapse=", ")))
      }
      
      if (length(warnings_list) > 0) {
        showModal(modalDialog(
          title = "Advarsel",
          HTML(paste(warnings_list, collapse = "<br/><br/>")),
          footer = modalButton("Forstået"),
          easyClose = TRUE,
          fade = FALSE
        ))
      }

      incProgress(1, detail = "Færdig!")
    })
  })
  
  # --- TRIN 4: OUTPUTS ---
  
  output$summary_text <- renderText({
    req(vals$routing_plan)
    n_days <- max(vals$routing_plan$Day)
    total_time <- sum(unique(vals$routing_plan[, c("Day", "DailyRouteTime_min")])$DailyRouteTime_min)
    paste0("Beregning færdig!\n",
           "Antal dage: ", n_days, "\n",
           "Total tidsforbrug: ", round(total_time, 0), " minutter.")
  })
  
  # Reactive map object for optimized route
  optimized_map_reactive <- reactive({
    req(vals$routing_plan)
    df <- vals$routing_plan
    pal <- colorFactor(palette = "Paired", domain = df$Day)
    orig_lon <- vals$origin_df$Longitude
    orig_lat <- vals$origin_df$Latitude
    
    map <- leaflet(df) %>% addTiles()
    
    days <- unique(df$Day)
    for(d in days) {
      day_data <- df %>% filter(Day == d) %>% arrange(StopOrder)
      lngs <- c(orig_lon, day_data$Longitude, orig_lon)
      lats <- c(orig_lat, day_data$Latitude, orig_lat)
      map <- map %>% addPolylines(lng = lngs, lat = lats, color = pal(d), weight = 3, opacity = 0.8)
    }
    
    map <- map %>%
      addCircleMarkers(lng = ~Longitude, lat = ~Latitude,
                       color = ~pal(Day), stroke = FALSE, fillOpacity = 0.8, radius = 8,
                       label = ~paste("Station:", StationName, "(", StationNumber, ")", "<br>Dag:", Day, "<br>Stop:", StopOrder),
                       popup = ~paste("<b>Station:</b>", StationName, "<br>",
                                      "<b>Nummer:</b>", StationNumber, "<br>",
                                      "<b>Prøvetid:</b>", SampleDuration_min, "min")) %>%
      addLegend("bottomright", pal = pal, values = ~Day, title = "Dag")
    map
  })
  
  output$map_optimized <- renderLeaflet({ optimized_map_reactive() })
  
  output$download_map_html <- downloadHandler(
    filename = function() { paste("ruteplan_kort_", Sys.Date(), ".html", sep="") },
    content = function(file) { saveWidget(optimized_map_reactive(), file = file, selfcontained = TRUE) }
  )
  
  output$schedule_table <- renderDT({
    req(vals$routing_plan)
    datatable(vals$routing_plan, options = list(pageLength = 25))
  })
  
  output$download_plan <- downloadHandler(
    filename = function() { paste("køreplan_", Sys.Date(), ".csv", sep = "") },
    content = function(file) { write.csv(vals$routing_plan, file, row.names = FALSE) }
  )
  output$download_plan_xlsx <- downloadHandler(
    filename = function() { paste("køreplan_", Sys.Date(), ".xlsx", sep = "") },
    content = function(file) { write.xlsx(vals$routing_plan, file) }
  )
  output$download_plan_html <- downloadHandler(
    filename = function() { paste("køreplan_", Sys.Date(), ".html", sep = "") },
    content = function(file) { saveWidget(datatable(vals$routing_plan), file = file, selfcontained = TRUE) }
  )
  
  # NEW: Download as BLG Format with 'gammel' lookup logic
  output$download_blg_format <- downloadHandler(
    filename = function() { paste("BLG_forslag_", Sys.Date(), ".csv", sep = "") },
    content = function(file) {
      
      # Create mapping from original data
      # vals$BLG_togter contains the loaded CSV
      mapping <- vals$BLG_togter %>% 
        select(ny, gammel) %>% 
        distinct(ny, .keep_all = TRUE) # Ensure unique 'ny' keys
      
      blg_output <- vals$routing_plan %>%
        left_join(mapping, by = c("StationNumber" = "ny")) %>%
        mutate(
          ny = StationNumber,
          # gammel comes from join. If NA (new station), fallback to StationNumber
          gammel = ifelse(is.na(gammel), StationNumber, gammel),
          navn = StationName,
          togt = Day
        ) %>%
        select(ny, gammel, navn, togt)
      
      write.table(blg_output, file, sep = ";", row.names = FALSE, quote = FALSE, fileEncoding = "UTF-8")
    }
  )
  
  # Kort: Nuværende Plan (Manuel)
  current_map_reactive <- reactive({
    req(vals$current_plan_detailed)
    df <- vals$current_plan_detailed
    pal <- colorFactor(palette = "Set2", domain = df$Day)
    orig_lon <- vals$origin_df$Longitude
    orig_lat <- vals$origin_df$Latitude
    
    map <- leaflet(df) %>% addTiles()
    
    days <- unique(df$Day)
    for(d in days) {
      day_data <- df %>% filter(Day == d) %>% arrange(StopOrder)
      lngs <- c(orig_lon, day_data$Longitude, orig_lon)
      lats <- c(orig_lat, day_data$Latitude, orig_lat)
      map <- map %>% addPolylines(lng = lngs, lat = lats, color = pal(d), weight = 3, opacity = 0.8)
    }
    
    map <- map %>%
      addCircleMarkers(lng = ~Longitude, lat = ~Latitude,
                       color = ~pal(Day), stroke = FALSE, fillOpacity = 0.8, radius = 6,
                       label = ~paste("Station:", StationName, "(", StationNumber, ")", "<br>Togt:", Day)) %>%
      addLegend("bottomright", pal = pal, values = ~Day, title = "Nuv. Togt")
    map
  })
  
  output$map_current <- renderLeaflet({ current_map_reactive() })
  
  output$download_map_current_html <- downloadHandler(
    filename = function() { paste("nuvaerende_plan_kort_", Sys.Date(), ".html", sep="") },
    content = function(file) { saveWidget(current_map_reactive(), file = file, selfcontained = TRUE) }
  )
  
  # Tabel: Nuværende Plan
  output$current_schedule_table <- renderDT({
    req(vals$current_plan_detailed)
    datatable(vals$current_plan_detailed, options = list(pageLength = 25))
  })
  output$download_current_plan <- downloadHandler(
    filename = function() { paste("nuværende_plan_detaljeret_", Sys.Date(), ".csv", sep = "") },
    content = function(file) { write.csv(vals$current_plan_detailed, file, row.names = FALSE) }
  )
  output$download_current_plan_xlsx <- downloadHandler(
    filename = function() { paste("nuværende_plan_detaljeret_", Sys.Date(), ".xlsx", sep = "") },
    content = function(file) { write.xlsx(vals$current_plan_detailed, file) }
  )
  output$download_current_plan_html <- downloadHandler(
    filename = function() { paste("nuværende_plan_detaljeret_", Sys.Date(), ".html", sep = "") },
    content = function(file) { saveWidget(datatable(vals$current_plan_detailed), file = file, selfcontained = TRUE) }
  )
  
  # OUTPUTS: RAW DATA (EDITABLE BLG)
  output$table_blg <- renderDT({
    req(vals$BLG_togter)
    datatable(vals$BLG_togter, 
              editable = TRUE, # Gør tabellen editerbar
              extensions = c('FixedColumns', 'FixedHeader'),
              options = list(
                pageLength = 15, 
                scrollX = TRUE,
                fixedHeader = TRUE,
                fixedColumns = list(leftColumns = 2) # Lås de to første kolonner (formodentlig ID/navn)
              ))
  })
  
  output$table_wms <- renderDT({
    req(vals$HydrometristationerWMS)
    datatable(vals$HydrometristationerWMS, options = list(pageLength = 15, scrollX = TRUE))
  })
  
  output$table_matrix <- renderDT({
    req(vals$time_matrix, vals$all_locations_final)
    mat_df <- as.data.frame(vals$time_matrix)
    names_vec <- vals$all_locations_final$StationName
    names_vec[names_vec == "Svendborg Lab"] <- "Lab" 
    colnames(mat_df) <- names_vec
    rownames(mat_df) <- names_vec
    datatable(mat_df, editable = TRUE, options = list(pageLength = 15, scrollX = TRUE), caption = "Rejsetid i minutter")
  })
  
  # Matrix edit observer
  observeEvent(input$table_matrix_cell_edit, {
    info <- input$table_matrix_cell_edit
    new_val <- as.numeric(info$value)
    if(!is.na(new_val)) {
      vals$time_matrix[info$row, info$col] <- new_val
    }
  })
  
  # Sammenligningstabel
  output$comparison_table <- renderTable({
    req(vals$routing_plan, vals$current_plan_detailed)
    
    # Statistik Nuværende (Manuel)
    nuv <- vals$current_plan_detailed
    total_nuv <- sum(unique(nuv[, c("Day", "DailyRouteTime_min")])$DailyRouteTime_min)
    avg_nuv <- total_nuv / length(unique(nuv$Day))
    days_nuv <- length(unique(nuv$Day))
    
    # Statistik Ny (Auto)
    ny <- vals$routing_plan
    total_ny <- sum(unique(ny[, c("Day", "DailyRouteTime_min")])$DailyRouteTime_min)
    avg_ny <- total_ny / length(unique(ny$Day))
    days_ny <- length(unique(ny$Day))
    
    data.frame(
      Parameter = c("Antal Dage (Togter)", "Total Tid (min)", "Gns. Tid pr. Dag (min)"),
      Nuværende = c(days_nuv, round(total_nuv, 0), round(avg_nuv, 0)),
      Ny_Plan = c(days_ny, round(total_ny, 0), round(avg_ny, 0))
    )
  }, digits = 0)
}

# Run the application 
shinyApp(ui = ui, server = server)
